Chapter 30: Multithreading And Parallel Programming
    1. Basic Concepts: 
        1.1 Multithreading
            "Multithreading enables multiple tasks in a program to be executed concurrently." (p.1098)
    
        1.2. Thread
            "A thread is the flow of execution, from beginning to end, of a task." (p.1098)
    
        1.3 Time Sharing 
            In a single processor system, the multiple threads share CPU time, which is known as the Time Sharing. As one CPU is shared among multiple threads, the OS is responsible for scheduling and allocating resources to them. In some cases, multithreaded programs can even perform better than single-thread programs on single-core CPU system.

    2. Multithread in Java
        2.1 Runnable
            In Java, each task is an instance of the Runnable, or i.e., a Runnable object.
        
        2.2 Thread
            A thread is an object facilitating the execution of such a task.

    3. Creating Tasks and Threads
        3.1 Creating Task:
            "A task class must implement the Runnable interface." (p.1099) Runnable is a Functional Interface, which contains only the run method. This method is essentially telling the thread is going to run this task. 
            
        3.2 Creating Thread:
            "A task must be run from a thread." (p.1099) A thread is craeted as follows by telling the task that it should execute:

                // The Class of task is a Runnable
                Thread thread = new Thread(task);

        3.3 Start the Thread:
            
            // call the start method
            thread.start()

        3.4 To Stop the Thread:
            "Instead of using the stop() method, you should assign null to a Thread variable to indicate that has stopped." (p.1103)

    4. More about Thread
        Thread Class implements the Runnable interface. You can extends the Thread class to implements methods for controling the threads.

        Further, as the Thread class implements Runnable interface. It is possible to extend Thread class override the run() method, so that no Runnable object is created.

        It is worth to know that in Thread class (JDK), it internally calls the Runnable object's run(), where the target is the Runnable object that is passed to the Thread class when it being instantiated.

            Thread thread = new Thread(target);

            "
                @Override
                public void run() {
                    if (target != null) {
                        target.run();
                    }
                }
            "
        
        Note that: stop(), suspend(), and resume() are unsafe, thus depreciated.

        4.1 yield() method
            yield() method is a static method in Thread. It allows to temporarily release time for other threads. 
            
            One better explaination from GeeksforGees: 
                "yield() basically means that the thread is not doing anything particularly important and if any other threads or processes need to be run, they should run. Otherwise, the current thread will continue to run."

            More Importantly:
                "Whenever a thread calls java.lang.Thread.yield method, it gives hint to the thread scheduler that it is ready to pause its execution. Thread scheduler is free to ignore this hint.

                If any thread executes yield method , thread scheduler checks if there is any thread with same or high priority than this thread. If processor finds any thread with higher or same priority then it will move the current thread to Ready/Runnable state and give processor to other thread and if not â€“ current thread will keep executing."

            [https://www.geeksforgeeks.org/java-concurrency-yield-sleep-and-join-methods/]

        4.2 sleep() method
            This method is a static method. Similar to yield() method, sleep() method also temporarily pause the thread, except that yield() is not guarantee to pause the thread, and sleep() method pause the thread for a specified time in milisec.

            The InterruptedException by the sleep() method must be handled, it is thrown when the current Thread is interrupted.

        4.3 join() method
            join() method forces one thread to wait for another thread to finish.

        4.4 Thread Priority
            Every thread is assigned a priority, a thread inherits the prioirty of the thread that creates it. For example, main thread has a priority of Thread.NORM_PRIORITY, which is a constant.

            To manually assign a priority to the thread, use setPriority() method. To get the priority of a thread, use getPriority() method.

            Priority are numbers ranged from 1 to 10. Thread provides int constants for priority:
                - MIN_PRIORITY (valud of 1)
                - NORM_PRIORITY (value of 5)
                - MAX_PRIORITY (value of 10)
            It is recommended to use the constant for assigning priority values.

            4.4.1 Round-Robin Scheduling 
                Round-Robin Scheduling is the situation where all threads have the same priorities, thus each is assigned the same portion of processing time in a circular queue.
            
            4.4.2 Contention or Starvation
                JVM always runs the higher priority threads, thus the thread with lower priority runs only when there is no higher-priority threads. 

                A thread may never run if there is always a higher-priority thread running, the thread of same-priority never pause or yields. This situation is known as Contention or Starvation. To avoids, the thread with higher priority should periodically calls the sleep method or yield method so that the threads with lower-priority can run.

        4.5 Thread in Javafx
            When handling threads that are associated with the controls of GUI components or controls (e.g., Pane, Label etc), the Runnable object should be handled by the Javafx.Platform as follows:

                // pass the Runnable object to the Javafx.
                Platform.runLater(Runnable r); 








         

        